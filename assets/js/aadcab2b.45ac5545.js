"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[231],{2026:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>t,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"fields","title":"Fields","description":"Models of kind \'entity\', \'object\', \'interface\' (see the docs on models) have an option called fields.","source":"@site/docs/3-fields.md","sourceDirName":".","slug":"/fields","permalink":"/graphql-magic/docs/fields","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{},"sidebar":"sidebar","previous":{"title":"Models","permalink":"/graphql-magic/docs/models"},"next":{"title":"Code generation","permalink":"/graphql-magic/docs/generation"}}');var l=s(4848),d=s(8453);const r={},t="Fields",a={},c=[{value:"Kinds",id:"kinds",level:2},{value:"Primitive fields",id:"primitive-fields",level:3},{value:"Enums",id:"enums",level:3},{value:"Custom",id:"custom",level:3},{value:"JSON",id:"json",level:3},{value:"Relations",id:"relations",level:3},{value:"Options",id:"options",level:2},{value:"<code>kind</code>",id:"kind",level:3},{value:"<code>type</code>",id:"type",level:3},{value:"<code>description</code>",id:"description",level:3},{value:"<code>list</code>",id:"list",level:3},{value:"<code>nonNull</code>",id:"nonnull",level:3},{value:"<code>defaultValue</code>",id:"defaultvalue",level:3},{value:"<code>args</code>",id:"args",level:3},{value:"<code>directives</code>",id:"directives",level:3},{value:"<code>primary</code>",id:"primary",level:3},{value:"<code>unique</code>",id:"unique",level:3},{value:"<code>filterable</code>",id:"filterable",level:3},{value:"<code>reverseFilterable</code>",id:"reversefilterable",level:3},{value:"<code>searchable</code>",id:"searchable",level:3},{value:"<code>orderable</code>",id:"orderable",level:3},{value:"<code>comparable</code>",id:"comparable",level:3},{value:"<code>queriable</code>",id:"queriable",level:3},{value:"<code>creatable</code>",id:"creatable",level:3},{value:"<code>updatable</code>",id:"updatable",level:3},{value:"<code>toOne</code>",id:"toone",level:3},{value:"<code>reverse</code>",id:"reverse",level:3},{value:"<code>onDelete</code>",id:"ondelete",level:3},{value:"<code>generateAs</code>",id:"generateas",level:3},{value:"<code>type: &#39;virtual&#39;</code> and <code>type: &#39;stored&#39;</code>",id:"type-virtual-and-type-stored",level:4},{value:"<code>type: &#39;expression&#39;</code>",id:"type-expression",level:4}];function o(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,d.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"fields",children:"Fields"})}),"\n",(0,l.jsxs)(n.p,{children:["Models of kind ",(0,l.jsx)(n.code,{children:"'entity'"}),", ",(0,l.jsx)(n.code,{children:"'object'"}),", ",(0,l.jsx)(n.code,{children:"'interface'"})," (see the docs on ",(0,l.jsx)(n.a,{href:"./models",children:"models"}),") have an option called ",(0,l.jsx)(n.code,{children:"fields"}),"."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:"const modelDefinitions: ModelDefinitions = [\n  {\n    kind: 'entity',\n    name: 'User',\n    fields: [\n      // Fields\n    ],\n  },\n];\n\nexport const models = new Models(modelDefinitions);\n"})}),"\n",(0,l.jsx)(n.h2,{id:"kinds",children:"Kinds"}),"\n",(0,l.jsxs)(n.p,{children:["Fields can have various kinds, based on the field ",(0,l.jsx)(n.code,{children:"kind"}),":"]}),"\n",(0,l.jsx)(n.h3,{id:"primitive-fields",children:"Primitive fields"}),"\n",(0,l.jsxs)(n.p,{children:["Primitive fields are fields where ",(0,l.jsx)(n.code,{children:"kind"})," is either undefined or set to ",(0,l.jsx)(n.code,{children:"'primitive'"}),". They can have the following ",(0,l.jsx)(n.code,{children:"type"}),":"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.code,{children:"ID"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.code,{children:"Boolean"})}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"String"})," with optional fields ",(0,l.jsx)(n.code,{children:"stringType"})," and ",(0,l.jsx)(n.code,{children:"maxLength"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"Int"})," with optional fields ",(0,l.jsx)(n.code,{children:"intType"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"Float"})," with optional fields ",(0,l.jsx)(n.code,{children:"floatType"}),", ",(0,l.jsx)(n.code,{children:"double"}),", ",(0,l.jsx)(n.code,{children:"precision"}),", ",(0,l.jsx)(n.code,{children:"scale"})]}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.code,{children:"Upload"})}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Examples:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:"{\n    name: 'Person',\n    fields: [\n        {\n            type: 'String',\n            name: 'name',\n        },\n        {\n            type: 'Int',\n            name: 'name',\n        }\n    ]\n}\n"})}),"\n",(0,l.jsx)(n.h3,{id:"enums",children:"Enums"}),"\n",(0,l.jsxs)(n.p,{children:["When ",(0,l.jsx)(n.code,{children:"kind"})," is ",(0,l.jsx)(n.code,{children:"enum"}),". Requires as ",(0,l.jsx)(n.code,{children:"type"})," the name of a separately defined model of kind ",(0,l.jsx)(n.code,{children:"'enum'"}),". Has optional field ",(0,l.jsx)(n.code,{children:"possibleValues"})," to allow only a subset of available values in mutations."]}),"\n",(0,l.jsx)(n.h3,{id:"custom",children:"Custom"}),"\n",(0,l.jsxs)(n.p,{children:["When ",(0,l.jsx)(n.code,{children:"kind"})," is ",(0,l.jsx)(n.code,{children:"custom"}),". Requires as ",(0,l.jsx)(n.code,{children:"type"})," the name of a separately defined model of kind ",(0,l.jsx)(n.code,{children:"'object'"}),"."]}),"\n",(0,l.jsxs)(n.p,{children:["If this is an entity field, ",(0,l.jsx)(n.code,{children:"graphql-magic"})," will not try to fetch the result from the database and instead assume the presence of a custom resolver for this field and ."]}),"\n",(0,l.jsx)(n.h3,{id:"json",children:"JSON"}),"\n",(0,l.jsxs)(n.p,{children:["This kind is only available in entity fields. When ",(0,l.jsx)(n.code,{children:"kind"})," is ",(0,l.jsx)(n.code,{children:"json"}),", ",(0,l.jsx)(n.code,{children:"graphql-magic"})," assumes that this is a ",(0,l.jsx)(n.code,{children:"json"})," column in the database and returns the data as is. The ",(0,l.jsx)(n.code,{children:"type"})," needs be the name of a separately defined model of kind ",(0,l.jsx)(n.code,{children:"object"})," that describes the structure of the ",(0,l.jsx)(n.code,{children:"JSON"}),"."]}),"\n",(0,l.jsx)(n.h3,{id:"relations",children:"Relations"}),"\n",(0,l.jsxs)(n.p,{children:["This kind is only available in entity fields. When ",(0,l.jsx)(n.code,{children:"kind"})," is ",(0,l.jsx)(n.code,{children:"relation"}),", the field describes a link to an entity table. The ",(0,l.jsx)(n.code,{children:"type"})," therefore needs to be the name of a model of kind ",(0,l.jsx)(n.code,{children:"'entity'"}),"."]}),"\n",(0,l.jsx)(n.h2,{id:"options",children:"Options"}),"\n",(0,l.jsx)(n.p,{children:"Fields generally have the following options:"}),"\n",(0,l.jsx)(n.h3,{id:"kind",children:(0,l.jsx)(n.code,{children:"kind"})}),"\n",(0,l.jsxs)(n.p,{children:["Fields can have various kinds, which affect other available options. For more details, see section on ",(0,l.jsx)(n.a,{href:"#kinds",children:"kinds"})," above."]}),"\n",(0,l.jsx)(n.h3,{id:"type",children:(0,l.jsx)(n.code,{children:"type"})}),"\n",(0,l.jsxs)(n.p,{children:['This represents the GraphQL "return type", which can be a primitive or a separate model (depending on the ',(0,l.jsx)(n.a,{href:"#kinds",children:"kind"}),")."]}),"\n",(0,l.jsx)(n.h3,{id:"description",children:(0,l.jsx)(n.code,{children:"description"})}),"\n",(0,l.jsx)(n.p,{children:"Will appear as description in the GraphQL schema."}),"\n",(0,l.jsx)(n.h3,{id:"list",children:(0,l.jsx)(n.code,{children:"list"})}),"\n",(0,l.jsxs)(n.p,{children:["If ",(0,l.jsx)(n.code,{children:"list"})," is ",(0,l.jsx)(n.code,{children:"true"})," the result is an array."]}),"\n",(0,l.jsx)(n.h3,{id:"nonnull",children:(0,l.jsx)(n.code,{children:"nonNull"})}),"\n",(0,l.jsx)(n.p,{children:"Will make the field required both in the GraphQL schema and in the database."}),"\n",(0,l.jsx)(n.h3,{id:"defaultvalue",children:(0,l.jsx)(n.code,{children:"defaultValue"})}),"\n",(0,l.jsx)(n.p,{children:"Will set this as default value in GraphQL mutations and in the database."}),"\n",(0,l.jsx)(n.h3,{id:"args",children:(0,l.jsx)(n.code,{children:"args"})}),"\n",(0,l.jsx)(n.p,{children:"An array of fields that can then be used as parameters, e.g. if this field is implemented as a custom resolver."}),"\n",(0,l.jsx)(n.h3,{id:"directives",children:(0,l.jsx)(n.code,{children:"directives"})}),"\n",(0,l.jsx)(n.p,{children:"Graphql directives for this field."}),"\n",(0,l.jsx)(n.h3,{id:"primary",children:(0,l.jsx)(n.code,{children:"primary"})}),"\n",(0,l.jsxs)(n.p,{children:["If ",(0,l.jsx)(n.code,{children:"true"})," this will generate a primary key in the database."]}),"\n",(0,l.jsx)(n.h3,{id:"unique",children:(0,l.jsx)(n.code,{children:"unique"})}),"\n",(0,l.jsxs)(n.p,{children:["If ",(0,l.jsx)(n.code,{children:"true"})," this will generate a unique key in the database."]}),"\n",(0,l.jsx)(n.h3,{id:"filterable",children:(0,l.jsx)(n.code,{children:"filterable"})}),"\n",(0,l.jsxs)(n.p,{children:["If true, this field will be available in the ",(0,l.jsx)(n.code,{children:"where"})," parameter for queries of this entity."]}),"\n",(0,l.jsx)(n.p,{children:"E.g. with"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:"{\n    name: 'Post',\n    fields: [\n        {\n            name: 'name',\n            type: 'String',\n            filterable: true\n        }\n    ]\n}\n"})}),"\n",(0,l.jsx)(n.p,{children:"this becomes possible:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-graphql",children:'query {\n  posts(where: { name: "Hello World" }) {\n    title\n  }\n}\n'})}),"\n",(0,l.jsx)(n.p,{children:"With relations, this enables sub-filters, e.g. with"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:"{\n    name: 'Comment',\n    fields: [\n        {\n            kind: 'relation',\n            name: 'post',\n            type: 'Post',\n            filterable: true\n        }\n    ]\n}\n"})}),"\n",(0,l.jsx)(n.p,{children:"this becomes possible:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-graphql",children:'query {\n  comments(where: { post: { name: "Hello World" } }) {\n    content\n  }\n}\n'})}),"\n",(0,l.jsx)(n.h3,{id:"reversefilterable",children:(0,l.jsx)(n.code,{children:"reverseFilterable"})}),"\n",(0,l.jsxs)(n.p,{children:["Only relevant on relation fields. On ",(0,l.jsx)(n.code,{children:"true"})," makes the reverse relation filterable."]}),"\n",(0,l.jsx)(n.p,{children:"E.g. with"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:"{\n    name: 'Comment',\n    fields: [\n        {\n            name: 'post',\n            type: 'String',\n            reverseFilterable: true\n        }\n    ]\n}\n"})}),"\n",(0,l.jsx)(n.p,{children:"this becomes possible:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-graphql",children:'query {\n  posts(where: { comments_SOME: { name: "Hello World" } }) {\n    title\n  }\n}\n'})}),"\n",(0,l.jsxs)(n.p,{children:["Available filter postfixes are ",(0,l.jsx)(n.code,{children:"_SOME"})," and ",(0,l.jsx)(n.code,{children:"_NONE"}),"."]}),"\n",(0,l.jsx)(n.h3,{id:"searchable",children:(0,l.jsx)(n.code,{children:"searchable"})}),"\n",(0,l.jsxs)(n.p,{children:["On ",(0,l.jsx)(n.code,{children:"true"})," makes the field searchable. Search always happens across all fields marked as searchable (only one has to match). Search is case insensitive."]}),"\n",(0,l.jsx)(n.p,{children:"E.g. with"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:"{\n    name: 'Post',\n    fields: [\n        {\n            name: 'title',\n            type: 'String',\n            searchable: true\n        },\n        {\n            name: 'content',\n            type: 'String',\n            searchable: true\n        }\n\n    ]\n}\n"})}),"\n",(0,l.jsx)(n.p,{children:"this becomes possible:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-graphql",children:'query {\n  posts(search: "Hello") {\n    title\n  }\n}\n'})}),"\n",(0,l.jsx)(n.h3,{id:"orderable",children:(0,l.jsx)(n.code,{children:"orderable"})}),"\n",(0,l.jsxs)(n.p,{children:["On ",(0,l.jsx)(n.code,{children:"true"})," makes the field available to the ",(0,l.jsx)(n.code,{children:"orderBy"})," parameter."]}),"\n",(0,l.jsx)(n.p,{children:"E.g. with"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:"{\n    name: 'Post',\n    fields: [\n        {\n            name: 'title',\n            type: 'String',\n            orderable: true\n        },\n    ]\n}\n"})}),"\n",(0,l.jsx)(n.p,{children:"this becomes possible:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-graphql",children:"query {\n  posts(orderBy: [{ title: DESC }]) {\n    title\n  }\n}\n"})}),"\n",(0,l.jsx)(n.h3,{id:"comparable",children:(0,l.jsx)(n.code,{children:"comparable"})}),"\n",(0,l.jsxs)(n.p,{children:["On ",(0,l.jsx)(n.code,{children:"true"})," makes the field comparable."]}),"\n",(0,l.jsx)(n.p,{children:"E.g. with"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:"{\n    name: 'Post',\n    fields: [\n        {\n            name: 'rating',\n            type: 'Int',\n            comparable: true\n        },\n    ]\n}\n"})}),"\n",(0,l.jsx)(n.p,{children:"this becomes possible:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-graphql",children:"query {\n    posts(where: { rating_GTE 4 }) {\n        title\n    }\n}\n"})}),"\n",(0,l.jsx)(n.p,{children:"Available postfixes are:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"_GT"}),": greater than"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"_GTE"}),": greater than or equal"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"_LT"}),": less than"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"_LTE"}),": less than or equal"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"queriable",children:(0,l.jsx)(n.code,{children:"queriable"})}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"true"})," by default. If explicitly set to ",(0,l.jsx)(n.code,{children:"false"}),", the field won't be queriable via GraphQL."]}),"\n",(0,l.jsxs)(n.p,{children:["Also accepts an object that defines a list of ",(0,l.jsx)(n.code,{children:"roles"})," to restrict access to specific roles."]}),"\n",(0,l.jsx)(n.h3,{id:"creatable",children:(0,l.jsx)(n.code,{children:"creatable"})}),"\n",(0,l.jsxs)(n.p,{children:["If ",(0,l.jsx)(n.code,{children:"true"})," this field will be available in the create mutation for the entity."]}),"\n",(0,l.jsxs)(n.p,{children:["Also accepts an object that defines a list of ",(0,l.jsx)(n.code,{children:"roles"})," to restrict creation to specific roles."]}),"\n",(0,l.jsx)(n.h3,{id:"updatable",children:(0,l.jsx)(n.code,{children:"updatable"})}),"\n",(0,l.jsxs)(n.p,{children:["If ",(0,l.jsx)(n.code,{children:"true"})," this field will be available in the update mutation for the entity."]}),"\n",(0,l.jsxs)(n.p,{children:["Also accepts an object that defines a list of ",(0,l.jsx)(n.code,{children:"roles"})," to restrict creation to specific roles."]}),"\n",(0,l.jsx)(n.h3,{id:"toone",children:(0,l.jsx)(n.code,{children:"toOne"})}),"\n",(0,l.jsxs)(n.p,{children:["Only available on relation fields. If ",(0,l.jsx)(n.code,{children:"toOne"})," is ",(0,l.jsx)(n.code,{children:"true"})," this marks a one-to-one relation, meaning that the reverse relation will not point to an array as is the default."]}),"\n",(0,l.jsx)(n.h3,{id:"reverse",children:(0,l.jsx)(n.code,{children:"reverse"})}),"\n",(0,l.jsxs)(n.p,{children:["Only available on relation fiels. ",(0,l.jsx)(n.code,{children:"graphql-magic"})," automatically generates a name for the reverse relation, e.g. for a ",(0,l.jsx)(n.code,{children:"Comment"})," pointing to ",(0,l.jsx)(n.code,{children:"Post"}),":"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:"{\n    name: 'Comment',\n    fields: [\n        {\n            kind: 'relation',\n            name: 'post',\n            type: 'Post'\n        }\n    ]\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:["the reverse relation will automatically be ",(0,l.jsx)(n.code,{children:"Post.comments"}),". With ",(0,l.jsx)(n.code,{children:"reverse"})," this name can be overridden."]}),"\n",(0,l.jsx)(n.h3,{id:"ondelete",children:(0,l.jsx)(n.code,{children:"onDelete"})}),"\n",(0,l.jsxs)(n.p,{children:["Only available on relation fields. Can be ",(0,l.jsx)(n.code,{children:'"cascade"'})," (default), ",(0,l.jsx)(n.code,{children:'"restrict"'})," or ",(0,l.jsx)(n.code,{children:'"set-null"'}),"."]}),"\n",(0,l.jsx)(n.h3,{id:"generateas",children:(0,l.jsx)(n.code,{children:"generateAs"})}),"\n",(0,l.jsx)(n.p,{children:"Only available on entity fields. Allows you to define fields that are computed from SQL expressions rather than stored directly. This option accepts an object with:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"expression"}),": A SQL expression string that defines how the field is computed"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"type"}),": One of ",(0,l.jsx)(n.code,{children:"'virtual'"}),", ",(0,l.jsx)(n.code,{children:"'stored'"}),", or ",(0,l.jsx)(n.code,{children:"'expression'"})]}),"\n"]}),"\n",(0,l.jsxs)(n.h4,{id:"type-virtual-and-type-stored",children:[(0,l.jsx)(n.code,{children:"type: 'virtual'"})," and ",(0,l.jsx)(n.code,{children:"type: 'stored'"})]}),"\n",(0,l.jsx)(n.p,{children:"These types create SQL generated columns in the database. The difference is:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"'virtual'"})}),": The value is computed on-the-fly when queried (not stored in the database)"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"'stored'"})}),": The value is computed and stored in the database (takes up space but faster queries)"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Both types affect the SQL schema and create actual database columns."}),"\n",(0,l.jsx)(n.p,{children:"Example:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:"{\n    name: 'Product',\n    fields: [\n        {\n            name: 'price',\n            type: 'Float',\n        },\n        {\n            name: 'quantity',\n            type: 'Int',\n        },\n        {\n            name: 'totalPrice',\n            type: 'Float',\n            generateAs: {\n                expression: 'price * quantity',\n                type: 'stored'\n            }\n        }\n    ]\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:["This creates a ",(0,l.jsx)(n.code,{children:"totalPrice"})," column in the database that is automatically computed as ",(0,l.jsx)(n.code,{children:"price * quantity"}),". The expression can reference other columns in the same table."]}),"\n",(0,l.jsx)(n.h4,{id:"type-expression",children:(0,l.jsx)(n.code,{children:"type: 'expression'"})}),"\n",(0,l.jsxs)(n.p,{children:["This type creates a field that is ",(0,l.jsx)(n.strong,{children:"not"})," stored in the database schema. Instead, the expression is evaluated at query time during SELECT operations. This is useful for:"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Computed fields that don't need to be stored"}),"\n",(0,l.jsx)(n.li,{children:"Fields that reference columns but shouldn't create database columns"}),"\n",(0,l.jsx)(n.li,{children:"Dynamic calculations that should always use the latest data"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Example:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:"{\n    name: 'Product',\n    fields: [\n        {\n            name: 'price',\n            type: 'Float',\n        },\n        {\n            name: 'quantity',\n            type: 'Int',\n        },\n        {\n            name: 'totalPrice',\n            type: 'Float',\n            generateAs: {\n                expression: 'price * quantity',\n                type: 'expression'\n            },\n            filterable: true,\n            comparable: true,\n            orderable: true\n        }\n    ]\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:["This creates a ",(0,l.jsx)(n.code,{children:"totalPrice"})," field that is computed at query time. The expression can reference other columns in the table, and column names in the expression are automatically resolved with proper table aliases."]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsxs)(n.strong,{children:["Important notes for ",(0,l.jsx)(n.code,{children:"type: 'expression'"}),":"]})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["The field does ",(0,l.jsx)(n.strong,{children:"not"})," create a database column"]}),"\n",(0,l.jsx)(n.li,{children:"The expression is evaluated during SELECT queries"}),"\n",(0,l.jsx)(n.li,{children:"Column references in the expression are automatically prefixed with the table alias"}),"\n",(0,l.jsxs)(n.li,{children:["Can be combined with ",(0,l.jsx)(n.code,{children:"filterable"}),", ",(0,l.jsx)(n.code,{children:"comparable"}),", ",(0,l.jsx)(n.code,{children:"orderable"}),", and ",(0,l.jsx)(n.code,{children:"searchable"})," options"]}),"\n",(0,l.jsx)(n.li,{children:"Works with all filter types (equality, arrays, null checks, comparisons)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Expression examples:"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:"// Simple calculation\n{\n    name: 'totalPrice',\n    type: 'Float',\n    generateAs: {\n        expression: 'price * quantity',\n        type: 'expression'\n    }\n}\n\n// Using SQL functions\n{\n    name: 'fullName',\n    type: 'String',\n    generateAs: {\n        expression: \"COALESCE(firstName || ' ' || lastName, 'Unknown')\",\n        type: 'expression'\n    }\n}\n\n// Conditional logic\n{\n    name: 'discountedPrice',\n    type: 'Float',\n    generateAs: {\n        expression: 'CASE WHEN discount > 0 THEN price * (1 - discount) ELSE price END',\n        type: 'expression'\n    }\n}\n"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Filtering expression fields:"})}),"\n",(0,l.jsxs)(n.p,{children:["When ",(0,l.jsx)(n.code,{children:"filterable: true"})," is set on an expression field, you can filter by it:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-graphql",children:"query {\n  products(where: { totalPrice_GT: 100 }) {\n    totalPrice\n  }\n}\n"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Ordering expression fields:"})}),"\n",(0,l.jsxs)(n.p,{children:["When ",(0,l.jsx)(n.code,{children:"orderable: true"})," is set on an expression field, you can order by it:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-graphql",children:"query {\n  products(orderBy: [{ totalPrice: DESC }]) {\n    totalPrice\n  }\n}\n"})})]})}function h(e={}){const{wrapper:n}={...(0,d.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(o,{...e})}):o(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>t});var i=s(6540);const l={},d=i.createContext(l);function r(e){const n=i.useContext(d);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:r(e.components),i.createElement(d.Provider,{value:n},e.children)}}}]);